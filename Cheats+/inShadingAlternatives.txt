		    // prepare everything for shading alternatives

		    // the intersection point
		    minIP[0] = ip[0];
		    minIP[1] = ip[1];
		    minIP[2] = ip[2];

		    switch (mesh.fgp) {
		    case 'f':
		    case 'F':
			
//			 // the normal is the surface normal 
//			 minN[0] = n[0];
//			 minN[1] = n[1]; 
//			 minN[2] = n[2];
//			  
//			 // the material is the material of the first triangle point 
//			 int matIndex = mesh.verticesMat[mesh.triangles[minIndex][0]];
//			 minMaterial = mesh.materials[matIndex]; 
//			 minMaterialN= mesh.materialsN[matIndex];
			
			break;
		    case 'g':
		    case 'G':
			// remember barycentric coordinates for shading
			bu = ai[0] / a;
			bv = ai[1] / a;
			bw = ai[2] / a;

			break;
		    case 'p':
		    case 'P':
			// the normal is barycentrically interpolated between
			// the three vertices
			bu = ai[0] / a;
			bv = ai[1] / a;
			bw = ai[2] / a;
			float nTemp[] = new float[3];
			nTemp[0] = bu * mesh.vertexNormals[mesh.triangles[minIndex][2]][0] + bv * mesh.vertexNormals[mesh.triangles[minIndex][0]][0] + bw
				* mesh.vertexNormals[mesh.triangles[minIndex][1]][0];
			nTemp[1] = bu * mesh.vertexNormals[mesh.triangles[minIndex][2]][1] + bv * mesh.vertexNormals[mesh.triangles[minIndex][0]][1] + bw
				* mesh.vertexNormals[mesh.triangles[minIndex][1]][1];
			nTemp[2] = bu * mesh.vertexNormals[mesh.triangles[minIndex][2]][2] + bv * mesh.vertexNormals[mesh.triangles[minIndex][0]][2] + bw
				* mesh.vertexNormals[mesh.triangles[minIndex][1]][2];
			normalize(nTemp);
			minN = nTemp;

			// intermediate version
			// the material is not interpolated
			// matIndex =
			// mesh.verticesMat[mesh.triangles[minIndex][0]];
			// minMaterial = mesh.materials[matIndex];
			// minMaterialN = mesh.materialsN[matIndex];

			// the material is barycentrically interpolated between
			// the three vertex materials
			int matIndex0 = mesh.verticesMat[mesh.triangles[minIndex][0]];
			int matIndex1 = mesh.verticesMat[mesh.triangles[minIndex][1]];
			int matIndex2 = mesh.verticesMat[mesh.triangles[minIndex][2]];
			float materialTemp[] = new float[9];
			int materialNTemp;
			for (int k = 0; k < 9; k++) {
			    materialTemp[k] = bu * mesh.materials[matIndex0][k] + bv * mesh.materials[matIndex1][k] + bw * mesh.materials[matIndex2][k];
			}
			minMaterial = materialTemp;
			materialNTemp = (int) (bu * mesh.materialsN[matIndex0] + bv * mesh.materialsN[matIndex1] + bw * mesh.materialsN[matIndex2]);
			minMaterialN = materialNTemp;
		    }
		}
	    } else
		continue; // return null;
	}

	// no intersection point found => return with no result
	if (minObjectsIndex == -1)
	    return null;
	
	// light vector at the intersection point
	l[0] = ICenter[0] - minIP[0];
	l[1] = ICenter[1] - minIP[1];
	l[2] = ICenter[2] - minIP[2];
	normalize(l);

	// decide which shading model will be applied

	// implicit: only phong shading available => shade=illuminate
	if (objects.get(minObjectsIndex) instanceof I_Sphere)
	    return phongIlluminate(minMaterial, minMaterialN, l, minN, v, Ia, Ids);
	
	// triangle mesh: flat, gouraud or phong shading according to file data
	else if (objects.get(minObjectsIndex).getHeader() == "TRIANGLE_MESH") {
	    mesh = ((T_Mesh) objects.get(minObjectsIndex));
	    switch (mesh.fgp) {
	    case 'f':
	    case 'F':
//		// illumination can be calculated here
//		// this is a variant between flat und phong shading
//		return phongIlluminate(minMaterial, minMaterialN, l, minN, v, Ia, Ids);
		
		// lookup triangle color of triangle hit
		return new Color(mesh.triangleColors[minIndex][0], mesh.triangleColors[minIndex][1], mesh.triangleColors[minIndex][2]);
	    case 'g':
	    case 'G':
		// the color is barycentrically interpolated between the three
		// vertex colors
		float colorf[] = new float[3];
		colorf[0] = bu * mesh.vertexColors[mesh.triangles[minIndex][2]][0] + bv * mesh.vertexColors[mesh.triangles[minIndex][0]][0] + bw
			* mesh.vertexColors[mesh.triangles[minIndex][1]][0];
		colorf[1] = bu * mesh.vertexColors[mesh.triangles[minIndex][2]][1] + bv * mesh.vertexColors[mesh.triangles[minIndex][0]][1] + bw
			* mesh.vertexColors[mesh.triangles[minIndex][1]][1];
		colorf[2] = bu * mesh.vertexColors[mesh.triangles[minIndex][2]][2] + bv * mesh.vertexColors[mesh.triangles[minIndex][0]][2] + bw
			* mesh.vertexColors[mesh.triangles[minIndex][1]][2];

		return new Color(colorf[0] < 1.0f ? colorf[0] : 1.0f, colorf[1] < 1.0f ? colorf[1] : 1.0f, colorf[2] < 1.0f ? colorf[2] : 1.0f);
	    case 'p':
	    case 'P':
		// calculate the color per per pixel phong lightning
		return phongIlluminate(minMaterial, minMaterialN, l, minN, v, Ia, Ids);
		// return new Color(material[3], material[4], material[5]);
		// break;

	    }
	}
	
	return null;
//	// intermediate version
//	Random rd = new Random();
//	return new Color(rd.nextFloat(), rd.nextFloat(), rd.nextFloat());


    }